\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

\usepackage{colortbl}

\usepackage{xstring}
\usepackage{karnaugh-map}

% imposta il titolo
\title{Appunti Reti Informatiche}
\author{Luca Seggiani}
\date{2025}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% circuiti
\usepackage{circuitikz}
\usetikzlibrary{babel}

% testo cerchiato
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}


\lstdefinelanguage{assembler}{ 
  keywords={AAA, AAD, AAM, AAS, ADC, ADCB, ADCW, ADCL, ADD, ADDB, ADDW, ADDL, AND, ANDB, ANDW, ANDL,
        ARPL, BOUND, BSF, BSFL, BSFW, BSR, BSRL, BSRW, BSWAP, BT, BTC, BTCB, BTCW, BTCL, BTR, 
        BTRB, BTRW, BTRL, BTS, BTSB, BTSW, BTSL, CALL, CBW, CDQ, CLC, CLD, CLI, CLTS, CMC, CMP,
        CMPB, CMPW, CMPL, CMPS, CMPSB, CMPSD, CMPSW, CMPXCHG, CMPXCHGB, CMPXCHGW, CMPXCHGL,
        CMPXCHG8B, CPUID, CWDE, DAA, DAS, DEC, DECB, DECW, DECL, DIV, DIVB, DIVW, DIVL, ENTER,
        HLT, IDIV, IDIVB, IDIVW, IDIVL, IMUL, IMULB, IMULW, IMULL, IN, INB, INW, INL, INC, INCB,
        INCW, INCL, INS, INSB, INSD, INSW, INT, INT3, INTO, INVD, INVLPG, IRET, IRETD, JA, JAE,
        JB, JBE, JC, JCXZ, JE, JECXZ, JG, JGE, JL, JLE, JMP, JNA, JNAE, JNB, JNBE, JNC, JNE, JNG,
        JNGE, JNL, JNLE, JNO, JNP, JNS, JNZ, JO, JP, JPE, JPO, JS, JZ, LAHF, LAR, LCALL, LDS,
        LEA, LEAVE, LES, LFS, LGDT, LGS, LIDT, LMSW, LOCK, LODSB, LODSD, LODSW, LOOP, LOOPE,
        LOOPNE, LSL, LSS, LTR, MOV, MOVB, MOVW, MOVL, MOVSB, MOVSD, MOVSW, MOVSX, MOVSXB,
        MOVSXW, MOVSXL, MOVZX, MOVZXB, MOVZXW, MOVZXL, MUL, MULB, MULW, MULL, NEG, NEGB, NEGW,
        NEGL, NOP, NOT, NOTB, NOTW, NOTL, OR, ORB, ORW, ORL, OUT, OUTB, OUTW, OUTL, OUTSB, OUTSD,
        OUTSW, POP, POPL, POPW, POPB, POPA, POPAD, POPF, POPFD, PUSH, PUSHL, PUSHW, PUSHB, PUSHA, 
				PUSHAD, PUSHF, PUSHFD, RCL, RCLB, RCLW, MOVSL, MOVSB, MOVSW, STOSL, STOSB, STOSW, LODSB, LODSW,
				LODSL, INSB, INSW, INSL, OUTSB, OUTSL, OUTSW
        RCLL, RCR, RCRB, RCRW, RCRL, RDMSR, RDPMC, RDTSC, REP, REPE, REPNE, RET, ROL, ROLB, ROLW,
        ROLL, ROR, RORB, RORW, RORL, SAHF, SAL, SALB, SALW, SALL, SAR, SARB, SARW, SARL, SBB,
        SBBB, SBBW, SBBL, SCASB, SCASD, SCASW, SETA, SETAE, SETB, SETBE, SETC, SETE, SETG, SETGE,
        SETL, SETLE, SETNA, SETNAE, SETNB, SETNBE, SETNC, SETNE, SETNG, SETNGE, SETNL, SETNLE,
        SETNO, SETNP, SETNS, SETNZ, SETO, SETP, SETPE, SETPO, SETS, SETZ, SGDT, SHL, SHLB, SHLW,
        SHLL, SHLD, SHR, SHRB, SHRW, SHRL, SHRD, SIDT, SLDT, SMSW, STC, STD, STI, STOSB, STOSD,
        STOSW, STR, SUB, SUBB, SUBW, SUBL, TEST, TESTB, TESTW, TESTL, VERR, VERW, WAIT, WBINVD,
        XADD, XADDB, XADDW, XADDL, XCHG, XCHGB, XCHGW, XCHGL, XLAT, XLATB, XOR, XORB, XORW, XORL},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{language=assembler, style=codestyle}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% tikz
\usepackage{tikz}

% float
\usepackage{float}

% grafici
\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi algoritmi
\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 03-10-25}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

% testo
\subsection{E-mail}
L'\textbf{e-mail} è un'altra delle applicazioni di largo uso sviluppate su Internet. Come ogni altra applicazione, è supportata da diversi \textit{protocolli}, fra cui \textbf{SMTP} (\textit{Simple Mail Transfer Protocol}), \textbf{IMAP} (\textit{Internet Message Access Protocol}), \textbf{POP} (\textit{Post Office Protocol}, di cui la più nota è la versione \textit{POP3}).

Nel sistema della posta elettronica ci sono 3 componenti principali:
\begin{itemize}
	\item Gli \textbf{user agent}, cioè i client di posta elettronica usati dagli utenti per scrivere e ricevere messaggi di posta elettronica;
	\item I \textbf{server} di posta elettronica;
	\item Un \textbf{protocollo} di posta elettronica, prendiamo SMTP. 
\end{itemize}

I mail server supportano:
\begin{itemize}
	\item Una \textbf{mailbox} che contiene i messaggi in arrivo per ogni utente;
	\item Una \textbf{coda} di messaggi in uscita: questi vengono poi smistati nelle mailbox dei vari utenti;
	\item Il \textbf{protocollo} SMTP per ricevere i messaggi dai client e inviarli ad altri mail server (vedremo che i client non usano direttamente SMTP per richiedere la posta, ma sfruttano altri protocolli).
\end{itemize}

Come sempre, notiamo che con \textit{mail server} si intende nello specifico il processo che gestisce le richieste degli utenti (e per estensione tutta la macchina (o macchine) che lo eseguono).

Il protocollo SMTP è un protocollo client-server: nonstante ciò, il mail server può comunicare con altri server, e in tal caso si comporta sia come client che come server.
\begin{itemize}
	\item Si comporta come \textit{client} quando deve inviare posta;
	\item Si comporta come \textit{server} quando deve ricevere posta.
\end{itemize}

Questo è chiaro in quanto è il server che \textit{invia} la posta a dover iniziare la comunicazione, mentre il server che \textit{riceve} deve essere solo pronto, appunto, a ricevere.

\subsubsection{Protocollo SMTP}
Nello specifico, il protocollo SMTP è basato su TCP aperto alla porta 25.
Il trasferimento è diretto, e come abbiamo già detto il server che invia si comporta come client per il server che riceve.

Ci sono 3 fasi di trasferimento:
\begin{itemize}
	\item Handshake fra i due server;
	\item Trasferimento di messaggi;
	\item Chiusura della comunicazione.
\end{itemize}

L'interazione è richiesta/risposta come in HTTP (anche se le richieste vengono dette \textit{comandi}), con messaggi codificati in ASCII a 7 bit.

I comandi contengono solo testo ASCII, mentre le risposte contengono un codice di stato seguito da testo, sempre ASCII, in linguaggio naturale.
Questo è per un motivo diagnostico: i comandi client sono letti dalla macchina, mentre del server la macchina legge solo il codice di stato e il commento ASCII è di debug per i tecnici. 

\par\smallskip

Facciamo un'esempio pratico per capire meglio il funzionamento del protocollo. Poniamo che Alice voglia inviare un messaggio a Biagio:
\begin{enumerate}
	\item Alice \lstinline|alice@unipi.it| usa l'user agent per comporre un messaggio e-mail al destinatario Biagio \lstinline|biagio@altroente.edu|;
	\item L'user agent di alice invia il messaggio al mail server di \lstinline|unipi.it| via SMTP, che lo mettte nella coda dei messaggi;
	\item Il mail server di Alice apre una connessione TCP, comportandosi come client, con il mail server \lstinline|altroente.edu|;
	\item Il messaggio di Alice viene trasferito verso tale mail server sulla rete TCP;
	\item Il mail server di Biagio mette il messaggio nella mailbox di Biagio;
	\item In un secondo momento, l'user agent di Biagio richiede la mailbox al suo mail server, che quindi gli invia il messaggio di Alice. 
\end{enumerate}

Qui il protcollo SMTP viene usato nella comunicazione fra l'UA di Alice ai server di \lstinline|unipi.it|, e nella comunicazione fra questi e i server di \lstinline|altroente.edu|.
Per portare la posta dai server di \lstinline|altroente.edu| all'UA di Biagio, invece, verrà usato un altro protocollo (come già detto IMAP o POP3).

Abbiamo quindi, per riassumere un ultima volta, che i mail server si comportano come \textit{client} quando devono \textit{inviare} messaggi ad altri mail server, e come \textit{server} quando devono \textit{ricevere} messaggi da altri mail server.
Verso gli user agent, invece, sono sempre server: si richiede al server di \textit{inviare} una mail, e si richiede al server di \textit{scaricare la mailbox} corrente (il server non ci contatterà come client per inviarci la posta come farebbe con un altro mail server, ma siamo noi a doverlo invocare). 

\subsubsection{Parole chiave SMTP}
Vediamo l'esempio dei messaggi che viaggiano in una connessione TCP, in plain text, durante lo svolgimento del protocollo TCP.
Mettiamo ad esempio di leggere la comunicazione fra il server \lstinline|unipi.it| al servizio di Alice dell'esempio precedente, quando questo inoltra la posta al mail server \lstinline|altroente.edu| di Biagio.

Qui \lstinline|S:| significa server (\lstinline|altroente.edu|) e \lstinline|C:| significa client (\lstinline|unipi.it|):
\begin{lstlisting}[language=html, style=codestyle]	
S: 220 altroente.edu
C: HELO unipi.it 
S: 250 Hello unipi.it, pleased to meet you
C: MAIL FROM: <alice@unipi.it>
S: 250 alice@unipi.it... Sender ok
C: RCPT TO: <biagio@altroente.edu>
S: 250 biagio@altroente.edu ... Recipient ok
C: DATA
S: 354 Enter mail, end with "." on a line by itself
C: Ciao Biagio ! 
C: .
S: 250 Message accepted for delivery
C: QUIT
S: 221 altroente.edu closing connection
\end{lstlisting}

Iniziamo con l'handshake: il server invia 220 (tutto ok) e il client si introduce con \lstinline|HELO| e il suo indirizzo: a questo punto il server risponde con \lstinline|250| (acknowledge dell'\lstinline|HELO|).

Da qui in poi il client può comunicare la posta che vuole inviare.
Con \lstinline|MAIL FROM| si indica l'indirizzo di posta elettronica dell'utente che sta inviando posta, a cui segue una risposta 250 dal server che segnala se quell'utente è riconosciuto. 
Con \lstinline|RCPT TO| si indica poi l'indirizzo di posta elettronica dell'utente destinatario, a cui segue un'altra risposta 250 dal server che segnala se quell'utente è presente sul mail server. 

Segue poi la sezione \lstinline|DATA|, a cui il server risponde con 354, e quindi la mail vera e propria.
Alla fine del messaggio (chiuso con un . su una nuova linea) il server risponde con un'altro 250, e il client chiude la connessione con \lstinline|QUIT|. L'ultimo acknowledge è del server con 221 (chiudo connessione).

\subsubsection{Confronto fra SMTP e HTTP}
Si può dire che HTTP è un protocollo di tipo \textbf{pull}, mentre SMTP è un protocollo di tipo \textbf{push}: in HTTP lato client si richiedono risorse, in SMTP si inviano.
Inoltre, in SMTP si usano connessioni \textit{persistenti}.

Abbiamo poi che in HTTP ogni oggetto è incapsulato in una risposta, mentre in SMTP si possono avere trasferimenti \textit{multipart} (più messaggi di posta per connessione TCP), e che in SMTP si usa ASCII su 7 bit.

\subsubsection{Protocolli di richiesta}
Come abbiamo detto, il protocollo SMTP è effettivamente usato solo per la comunicazione fra mail server e per inviare messaggi a mail server: per richiedere la posta dal server si usano altri protocolli come \textbf{IMAP} (\textit{Internet Messagge Access Protocol}) e \textbf{POP} (\textit{Post Office Protocol}).
Questi protocolli forniscono la possibilità di fare richieste di messaggi, eliminazione, accesso a directory di messaggi presenti sul server, ecc...

Inoltre, servizi come Gmail e Hotmail forniscono interfacce Web (via il protocollo HTTP) costruite su SMTP (per inviare messaggi) e IMAP (o POP, in particolare POP3) per richiedere messaggi. 

La differenza principale fra IMAP e POP è che \textit{POP} era pensato per singoli dispositivi: la posta veniva scaricata su locale e rimossa dal server, per cui non vi si poteva accedere da altri dispositivi.
\textit{IMAP} risolve questo problema mantenendo i messaggi sul server e concedendone l'accesso da parte di più dispositivi.
In verità, oggi la maggior parte dei mail server è configurato per mantenere in remoto anche la posta scaricata via POP3.
Per client locali questo significa che IMAP e POP3 distinguono fondamentalmente fra due politiche più o meno aggresive di caching, mentre i client su HTTP usavano in ogni caso IMAP (non si scarica mai nessun messaggio sul disco locale).

Per concludere, da quello che abbiamo appreso in 4.2.1, possiamo dire che POP è \textit{stateless}, mentre IMAP è \textit{stateful} (mantiene stato sotto forma di mail precedenti). 

\subsection{Il DNS}
\textbf{DNS} (\textit{Domain Name System}) è il sistema che usiamo per tradurre \textit{nomi di dominio} DNS, semplici da ricordare per gli umani, in \textit{indirizzi IP}, semplici da usare per le macchine.

\subsubsection{Motivazione del DNS}
Di base, un'\textbf{indirizzo IP}v4 (IP versione 4) è rappresentato da un numero a 32 bit, diviso in 4 numeri da 8 bit rappresentati come unsigned e separati da punti: 8.8.8.8 (il servizio DNS di Google) sarebbe \lstinline|00001000_00001000_00001000_00001000|.
Un certo numero di bit dal più significativo vengono detti \textbf{maschera} di rete, ed identificano la parte dell'IP che identifica la rete locale: i bit successivi identificano gli host.
Ad esempio, \lstinline|10.104.111.163/24| significa che i primi 24 bit identificano la rete, e i successivi 8 gli host su quella rete. 

Il problema è che gli indirizzi IP sono difficili da ricordare: gli umani preferiscono indirizzi leggibili come \lstinline|tizio.caio.com|, cioè i cosiddetti \textbf{nomi di dominio}.

\subsubsection{Realizzazione del DNS}

Per tradurre da indirizzi leggibili a indirizzi IP (necessari per aprire connessioni TCP o UDP e quindi comunicare effettivamente col server) si usa il DNS.

I problemi del DNS sono quindi:
\begin{enumerate}
	\item Mantenere l'\textbf{univocità} dei nomi di dominio verso gli indirizzi IP;
	\item Permettere di risalire (\textbf{risolvere}) da un nome DNS all'indirizzo IP corrispondente.
\end{enumerate}

La soluzione che è stata data è di creare un \textit{database distribuito} implementato con una gerarchia di tanti \textit{name server} che contengono \textbf{registri} di nomi di dominio. Protocolli a livello application permettono quindi agli host (e a loro volta i name server) di \textbf{risolvere} nomi di domini DNS in indirizzi.

Questo rappresenta una funzione base di Internet, implementata al livello application, e che distribuisce la maggior parte della complessità all'\textit{"edge"} di internet.

Per assicurare l'univocità si sono formate \textit{autorità} come \textbf{ICANN} (\textit{Internet Corporation for Assigned Numbers and Names}), e la sussidiaria \textbf{IANA} (\textit{Internet Assigned Numbers Authority}) che definiscono quali domini possono essere usati in base all'area di applicazione, geografica, ecc...
Queste autorità delegano quindi ad altre autorità il compito di assegnare nomi, i cosiddetti identificatori \textit{top-level}, \textbf{TLD} (\textit{Top Level Domain}) a determinate regioni geografiche (\lstinline|.uk|, \lstinline|.io|, ecc...) e gestirne i domini, e la cosa può chiaramente ripetersi ricorsivamente, fino al cosiddetto livello \textit{autoritativo}, dove la traduzione in IP può effettivamente accadere.

In particolare, l'autorità di registrazione dell'identificatore top-level (\lstinline|.it|) risiede a Pisa all'interno del CNR. 

Come sappiamo, esistono anche domini top-level associati non ad entità geografiche ma generici, come \lstinline|.com|, \lstinline|.org|, ecc...
Questi sono amministrati direttamente dall'ICANN, mentre i registri sono detenuti da compagnie private.

\subsubsection{Funzionamento del DNS}

La risoluzione dei nomi di dominio viene fatta in maniera simile a quella degli indirizzi IP, partendo da destra verso sinistra per risalire al name server che contiene l'IP cercato.
Ad esempio, nel DNS \lstinline|www.google.com|, prima si controlla il \lstinline|com| per capire il primo name server da contattare. Questo a sua volta prendera il \lstinline|google| per contattare il prossimo name server, e così via.
Il \lstinline|www| è arcaico e viene mantenuto principalmente per ragioni storiche.

Abbiamo quindi che i problemi prima nominati vengono risolti rispettivamente nei seguenti modi:
\begin{enumerate}
	\item L'\textit{univocità} dei nomi di dominio è assicurata da \textbf{autorità} nazionali ed internazionali (ICANN, IANA, ecc...);
	\item La risoluzione da un nome di dominio DNS all'indirizzo IP corrispondente è assicurata da \textbf{name server} che contengono \textbf{registri} di nomi di dominio.
\end{enumerate}

Non è detto che le autorità che gestiscono un TLD gestiscono anche il registro corrispondente (abbiamo detto che questo non è il caso per i TLD generali come \lstinline|.com|).

\subsubsection{Risoluzione DNS}
Vediamo i dettagli tecnici.
Un server DNS comunica con un attraverso protocollo coi client, fornendo i servizi:
\begin{itemize}
	\item \textbf{Risoluzione} da dominio a indirizzo IP;
	\item \textbf{Aliasing} degli \textbf{host}: più nomi possono puntare allo stesso IP;
	\item \textbf{Aliasing} dei server di \textbf{posta}: allo stesso dominio possono corrispondere web server come mail server;
	\item \textbf{Distribuzione} del \textbf{carico}: più server (con i loro IP) possono rispondere allo stesso nome di dominio per dividersi le richieste.
\end{itemize}

Abbiamo detto che il DNS è un database \textbf{distribuito}, quindi sviluppato gerarchicamente su più \textit{name server}.
Questa soluzione è stata scelta, al contrario di un database \textit{centralizzato}, per una serie di motivi:
\begin{itemize}
	\item Evita un singolo punto di fallimento;
	\item Riduce il volume di traffico su ogni name server;
	\item Il database centrale risulterebbe molto distante per larga parte degli utenti (distribuiti su tutto il mondo);
	\item La manutenzione è più semplice (si fa su unità più piccole).
\end{itemize}

\subsubsection{Database DNS}
La struttura gerarchica del DNS è modellizzabile come una serie di registri che rimandano l'uno all'altro:
\begin{center}
	\begin{forest}
		[DNS Root, rectstyle
		[DNS .com
			[DNS yahoo.com]
			[DNS google.com]
		]
		[DNS .org
			[DNS pbs.org]
		]
		[DNS .edu
			[DNS nyu.edu]
			[DNS umass.edu]
		]
		]	
	\end{forest}
\end{center}

I registri ad ogni livello sono raggruppati in diverse categorie:
\begin{enumerate}
	\item \textbf{Root}, il registro base che punta agli altri registri;
	\item \textbf{TLD} (\textit{Top Level Domain}), che contiene i domini top-level nazionali (\lstinline|.jp|, \lstinline|.it|, ecc...) o generici (\lstinline|.org|, \lstinline|.edu|, ecc...);
	\item \textbf{Autoritativi}, i server DNS che si raggiungono dai TLD (o da server DNS ad altri \textit{sottodomini}) e che hanno effettivamente il compito di terminare la risoluzione per quel dominio restituendo un IP.
\end{enumerate}

Quando un client vuole risolvere un DNS, ad esempio per \lstinline|www.google.com|, compie i seguenti passi:
\begin{enumerate}
	\item Si rivolge al root server per trovare il server DNS \lstinline|.com|;
	\item Si rivolge al server DNS \lstinline|.com| per trovare il server DNS \lstinline|google.com|;
	\item Si rivolge al server DNS \lstinline|google.com| per ottenere l'IP di \lstinline|www.google.com|.
\end{enumerate}

In verità, la situazione è più complicata: i server Root sono più di uno (13), e sono largamente replicati (più di 200 solo negli Stati Uniti). Questo è fondamentale in quanto la sicurezza del servizio DNS deve essere assicurata.

Addirittura, i server sia TLD che autoritativi vengono replicati, usando configurazioni \textit{primario/secondario} o meccanismi come \textit{anycast} per assicurare la ridondanza del servizio.

\subsubsection{Server DNS locali}
Ogni ISP fornisce solitamente un server DNS proprio, detto anche \textit{Default Name Server}.
Anche i DNS locali sono solitamente configurati con name server \textit{primario/secondario} da contattare nel caso l'uno o l'altro fallisca. 

Quando un host fa una richiesta DNS ad un server DNS locale, questo controlla la sua cache, comportandosi quindi da proxy, e inoltrando la richiesta al DNS Root (o molto più tipicamente a un servizio di risoluzione DNS, sopratutto nel caso di router che per motivi economici non implementano l'intero protocollo DNS) solamente se non è capace di soddisfare la richiesta da solo.

Il meccanismo di caching è supportato dalla struttura gerarchica dei nomi di dominio DNS: ad esempio se il DNS locale conosce \lstinline|dns.nyu.edu|, potrebbe rispondere alle richieste di risoluzione di \lstinline|engineering.nyu.edu| inviando richieste direttamente al server autoritativo \lstinline|nyu.edu|, che ha già contattato.

Abbiamo quindi che un host connesso ad un ISP (come un comune router) si rivolge solitamente al servizio DNS fornito da tale ISP per le sue richieste DNS.
Questo quindi usa un servizio di risoluzione pubblico come 1.1.1.1 (Cloudflare) o 8.8.8.8 (Google) per risolvere il DNS (si dice che si comporta da \textit{forwarder} DNS), o in alcuni casi si comporta esso stesso come risolutore DNS contattando direttamente il server Root.

Nessuno ci nega (e a volte avviene) che l'host eviti il DNS locale rivolgendosi direttamente a un servizio di risoluzione.

\subsubsection{Risoluzione iterativa/ricorsiva}
La risoluzione dei nomi di domnio DNS da parte di un server DNS locale che si comporta come risolutore DNS (come da parte di un risolutore pubblico come quelli nominati sopra) può accadere in due modi principali: \textbf{iterativo} e \textbf{ricorsivo}:
\begin{itemize}
	\item \textbf{Iterativo}: in questo caso il server DNS si rivolge ad altri server DNS accettando sia traduzioni complete che riferimenti ad altri server DNS: nel caso il server contattato non possa tradurre potrà almeno reindirizzarci verso un server che può farlo;
	\item \textbf{Ricorsivo}: in questo caso il server DNS accetta solo traduzioni complete, o al limite messaggi che segnalano il fallimento della richiesta.
		Questa è la modalità in cui vengono interrogati la maggior parte dei servizi di risoluzione pubblici.

		Dal punto di vista interno la soluzione che si ha è che ogni DNS server contattato si prende la briga di contattare il successivo con una nuova richiesta DNS, e non di restituire solamente l'IP del prossimo elemento della catena, effettivamente sollevando il carico dal server DNS locale.
\end{itemize}

\end{document}
